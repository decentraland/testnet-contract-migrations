{
  "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/managers/RaritiesWithOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport '../interfaces/ICollectionManager.sol';\\nimport '../interfaces/IOracle.sol';\\nimport '../commons/OwnableInitializable.sol';\\nimport '../commons/NativeMetaTransaction.sol';\\nimport '../libs/String.sol';\\n\\ncontract RaritiesWithOracle is OwnableInitializable, NativeMetaTransaction {\\n    using String for string;\\n    using SafeMath for uint256;\\n\\n    struct Rarity {\\n        string name;\\n        uint256 maxSupply;\\n        uint256 price;\\n    }\\n\\n    Rarity[] public rarities;\\n\\n    /// @dev indexes will start in 1\\n    mapping(bytes32 => uint256) rarityIndex;\\n\\n    IOracle public oracle;\\n\\n    event AddRarity(Rarity _rarity);\\n    event UpdatePrice(string _name, uint256 _price);\\n    event OracleSet(IOracle indexed _oldOracle, IOracle indexed _newOracle);\\n\\n    /**\\n     * @notice Create the contract\\n     * @dev Rarity price is the price of a rarity in the rate returned by the oracle.\\n     *      For example if the oracle returns the rate of USD by MANA, then the price of the rarity\\n     *      has to be in USD\\n     * @param _owner - owner of the contract\\n     */\\n    constructor(\\n        address _owner,\\n        Rarity[] memory _rarities,\\n        IOracle _oracle\\n    ) {\\n        // EIP712 init\\n        _initializeEIP712('Decentraland Rarities', '1');\\n        // Ownable init\\n        _initOwnable();\\n        setOracle(_oracle);\\n        transferOwnership(_owner);\\n\\n        for (uint256 i = 0; i < _rarities.length; i++) {\\n            _addRarity(_rarities[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Set the oracle\\n     * @param _newOracle - oracle contract\\n     */\\n    function setOracle(IOracle _newOracle) public onlyOwner {\\n        require(\\n            address(_newOracle) != address(0),\\n            'Rarities#setOracle: INVALID_ORACLE'\\n        );\\n\\n        emit OracleSet(oracle, _newOracle);\\n        oracle = _newOracle;\\n    }\\n\\n    function updatePrices(string[] calldata _names, uint256[] calldata _prices)\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            _names.length == _prices.length,\\n            'Rarities#updatePrices: LENGTH_MISMATCH'\\n        );\\n\\n        for (uint256 i = 0; i < _names.length; i++) {\\n            string memory name = _names[i];\\n            uint256 price = _prices[i];\\n            bytes32 rarityKey = keccak256(bytes(name.toLowerCase()));\\n            uint256 index = rarityIndex[rarityKey];\\n\\n            require(\\n                rarityIndex[rarityKey] > 0,\\n                'Rarities#updatePrices: INVALID_RARITY'\\n            );\\n\\n            rarities[index - 1].price = price;\\n\\n            emit UpdatePrice(name, price);\\n        }\\n    }\\n\\n    function addRarities(Rarity[] memory _rarities) external onlyOwner {\\n        for (uint256 i = 0; i < _rarities.length; i++) {\\n            _addRarity(_rarities[i]);\\n        }\\n    }\\n\\n    function _addRarity(Rarity memory _rarity) internal {\\n        uint256 rarityLength = bytes(_rarity.name).length;\\n        require(\\n            rarityLength > 0 && rarityLength <= 32,\\n            'Rarities#_addRarity: INVALID_LENGTH'\\n        );\\n\\n        bytes32 rarityKey = keccak256(bytes(_rarity.name.toLowerCase()));\\n        require(\\n            rarityIndex[rarityKey] == 0,\\n            'Rarities#_addRarity: RARITY_ALREADY_ADDED'\\n        );\\n\\n        rarities.push(_rarity);\\n\\n        rarityIndex[rarityKey] = rarities.length;\\n\\n        emit AddRarity(_rarity);\\n    }\\n\\n    /**\\n     * @notice Returns the amount of item in the collection\\n     * @return Amount of items in the collection\\n     */\\n    function raritiesCount() external view returns (uint256) {\\n        return rarities.length;\\n    }\\n\\n    /**\\n     * @notice Returns a rarity with the price updated to reflect its price\\n     *         in the expected token. For example, the price is set in USD \\n     *         but it has to be paid in MANA so the price will be returned \\n     *         rated in MANA instead.\\n     * @dev will revert if the rarity is out of bounds\\n     * @return rarity for the given index\\n     */\\n    function getRarityByName(string memory _rarity)\\n        public\\n        view\\n        returns (Rarity memory)\\n    {\\n        bytes32 rarityKey = keccak256(bytes(_rarity.toLowerCase()));\\n\\n        uint256 index = rarityIndex[rarityKey];\\n\\n        require(\\n            rarityIndex[rarityKey] > 0,\\n            'Rarities#getRarityByName: INVALID_RARITY'\\n        );\\n\\n        Rarity memory rarity = rarities[index - 1];\\n\\n        uint256 originalPrice = rarity.price;\\n        uint256 rate = _getRateFromOracle();\\n        uint256 finalPrice = originalPrice.mul(1 ether).div(rate);\\n\\n        rarity.price = finalPrice;\\n\\n        return rarity;\\n    }\\n\\n    /**\\n    * @dev Safely call Oracle.getRate\\n    * @return Rate\\n    */\\n    function _getRateFromOracle() internal view returns(uint256) {\\n        /* solium-disable-next-line */\\n        (bool success, bytes memory data) = address(oracle).staticcall(\\n            abi.encodeWithSelector(oracle.getRate.selector)\\n        );\\n\\n        require(success, \\\"Rarities#_getRateFromOracle: INVALID_RATE_FROM_ORACLE\\\");\\n\\n        return abi.decode(data, (uint256));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICollectionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\npragma experimental ABIEncoderV2;\\n\\n\\ninterface ICollectionManager {\\n   function manageCollection(address _forwarder, address _collection, bytes calldata _data) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\npragma experimental ABIEncoderV2;\\n\\ninterface IOracle {\\n    function getRate() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/commons/OwnableInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"./ContextMixin.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableInitializable is ContextMixin {\\n    address internal _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function _initOwnable () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"\r\n    },\r\n    \"contracts/commons/NativeMetaTransaction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport { EIP712Base } from \\\"./EIP712Base.sol\\\";\\n\\ncontract NativeMetaTransaction is EIP712Base {\\n    using SafeMath for uint256;\\n    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(\\n        bytes(\\n            \\\"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\\\"\\n        )\\n    );\\n    event MetaTransactionExecuted(\\n        address userAddress,\\n        address relayerAddress,\\n        bytes functionSignature\\n    );\\n    mapping(address => uint256) nonces;\\n\\n    struct MetaTransaction {\\n        uint256 nonce;\\n        address from;\\n        bytes functionSignature;\\n    }\\n\\n    function executeMetaTransaction(\\n        address userAddress,\\n        bytes memory functionSignature,\\n        bytes32 sigR,\\n        bytes32 sigS,\\n        uint8 sigV\\n    ) external payable returns (bytes memory) {\\n        MetaTransaction memory metaTx = MetaTransaction({\\n            nonce: nonces[userAddress],\\n            from: userAddress,\\n            functionSignature: functionSignature\\n        });\\n\\n        require(\\n            verify(userAddress, metaTx, sigR, sigS, sigV),\\n            \\\"NMT#executeMetaTransaction: SIGNER_AND_SIGNATURE_DO_NOT_MATCH\\\"\\n        );\\n\\n        // increase nonce for user (to avoid re-use)\\n        nonces[userAddress] = nonces[userAddress].add(1);\\n\\n        emit MetaTransactionExecuted(\\n            userAddress,\\n            msg.sender,\\n            functionSignature\\n        );\\n\\n        // Append userAddress and relayer address at the end to extract it from calling context\\n        (bool success, bytes memory returnData) = address(this).call{value: msg.value}(\\n            abi.encodePacked(functionSignature, userAddress)\\n        );\\n        require(success, \\\"NMT#executeMetaTransaction: CALL_FAILED\\\");\\n\\n        return returnData;\\n    }\\n\\n    function hashMetaTransaction(MetaTransaction memory metaTx)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    META_TRANSACTION_TYPEHASH,\\n                    metaTx.nonce,\\n                    metaTx.from,\\n                    keccak256(metaTx.functionSignature)\\n                )\\n            );\\n    }\\n\\n    function getNonce(address user) external view returns (uint256 nonce) {\\n        nonce = nonces[user];\\n    }\\n\\n    function verify(\\n        address signer,\\n        MetaTransaction memory metaTx,\\n        bytes32 sigR,\\n        bytes32 sigS,\\n        uint8 sigV\\n    ) internal view returns (bool) {\\n        require(signer != address(0), \\\"NMT#verify: INVALID_SIGNER\\\");\\n        return\\n            signer ==\\n            ecrecover(\\n                toTypedMessageHash(hashMetaTransaction(metaTx)),\\n                sigV,\\n                sigR,\\n                sigS\\n            );\\n    }\\n}\"\r\n    },\r\n    \"contracts/libs/String.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\nlibrary String {\\n\\n    /**\\n     * @dev Convert bytes32 to string.\\n     * @param _x - to be converted to string.\\n     * @return string\\n     */\\n    function bytes32ToString(bytes32 _x) internal pure returns (string memory) {\\n        bytes memory bytesString = new bytes(32);\\n        uint charCount = 0;\\n        for (uint j = 0; j < 32; j++) {\\n            bytes1 currentChar = bytes1(bytes32(uint(_x) * 2 ** (8 * j)));\\n            if (currentChar != 0) {\\n                bytesString[charCount] = currentChar;\\n                charCount++;\\n            }\\n        }\\n        bytes memory bytesStringTrimmed = new bytes(charCount);\\n        for (uint j = 0; j < charCount; j++) {\\n            bytesStringTrimmed[j] = bytesString[j];\\n        }\\n        return string(bytesStringTrimmed);\\n    }\\n\\n    /**\\n     * @dev Convert uint to string.\\n     * @param _i - uint256 to be converted to string.\\n     * @return _uintAsString uint in string\\n     */\\n    function uintToString(uint _i) internal pure returns (string memory _uintAsString) {\\n        uint i = _i;\\n\\n        if (i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint j = i;\\n        uint len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint k = len - 1;\\n        while (i != 0) {\\n            bstr[k--] = bytes1(uint8(48 + i % 10));\\n            i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    /**\\n     * @dev Convert an address to string.\\n     * @param _x - address to be converted to string.\\n     * @return string representation of the address\\n     */\\n    function addressToString(address _x) internal pure returns (string memory) {\\n        bytes memory s = new bytes(40);\\n        for (uint i = 0; i < 20; i++) {\\n            bytes1 b = bytes1(uint8(uint160(_x) / (2**(8*(19 - i)))));\\n            bytes1 hi = bytes1(uint8(b) / 16);\\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n            s[2*i] = char(hi);\\n            s[2*i+1] = char(lo);\\n        }\\n        return string(s);\\n    }\\n\\n    function char(bytes1 b) internal pure returns (bytes1 c) {\\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n        else return bytes1(uint8(b) + 0x57);\\n    }\\n\\n    /**\\n     * @dev Lowercase a string.\\n     * @param _str - to be converted to string.\\n     * @return string\\n     */\\n    function toLowerCase(string memory _str) internal pure returns (string memory) {\\n        bytes memory bStr = bytes(_str);\\n        bytes memory bLower = new bytes(bStr.length);\\n\\n        for (uint i = 0; i < bStr.length; i++) {\\n            // Uppercase character...\\n            if ((bStr[i] >= 0x41) && (bStr[i] <= 0x5A)) {\\n                // So we add 0x20 to make it lowercase\\n                bLower[i] = bytes1(uint8(bStr[i]) + 0x20);\\n            } else {\\n                bLower[i] = bStr[i];\\n            }\\n        }\\n        return string(bLower);\\n    }\\n}\"\r\n    },\r\n    \"contracts/commons/ContextMixin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\n\\nabstract contract ContextMixin {\\n    function _msgSender()\\n        internal\\n        view\\n        virtual\\n        returns (address payable sender)\\n    {\\n        if (msg.sender == address(this)) {\\n            bytes memory array = msg.data;\\n            uint256 index = msg.data.length;\\n            assembly {\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\n                sender := and(\\n                    mload(add(array, index)),\\n                    0xffffffffffffffffffffffffffffffffffffffff\\n                )\\n            }\\n        } else {\\n            sender = msg.sender;\\n        }\\n        return sender;\\n    }\\n}\"\r\n    },\r\n    \"contracts/commons/EIP712Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\n\\ncontract EIP712Base {\\n    struct EIP712Domain {\\n        string name;\\n        string version;\\n        address verifyingContract;\\n        bytes32 salt;\\n    }\\n\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\\n        bytes(\\n            \\\"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\\\"\\n        )\\n    );\\n    bytes32 public domainSeparator;\\n\\n    // supposed to be called once while initializing.\\n    // one of the contractsa that inherits this contract follows proxy pattern\\n    // so it is not possible to do this in a constructor\\n    function _initializeEIP712(\\n        string memory name,\\n        string memory version\\n    )\\n        internal\\n    {\\n        domainSeparator = keccak256(\\n            abi.encode(\\n                EIP712_DOMAIN_TYPEHASH,\\n                keccak256(bytes(name)),\\n                keccak256(bytes(version)),\\n                address(this),\\n                bytes32(getChainId())\\n            )\\n        );\\n    }\\n\\n    function getChainId() public pure returns (uint256) {\\n        uint256 id;\\n        assembly {\\n            id := chainid()\\n        }\\n        return id;\\n    }\\n\\n    /**\\n     * Accept message hash and returns hash message in EIP712 compatible form\\n     * So that it can be used to recover signer from signature signed using EIP712 formatted data\\n     * https://eips.ethereum.org/EIPS/eip-712\\n     * \\\"\\\\\\\\x19\\\" makes the encoding deterministic\\n     * \\\"\\\\\\\\x01\\\" is the version byte to make it compatible to EIP-191\\n     */\\n    function toTypedMessageHash(bytes32 messageHash)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, messageHash)\\n            );\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}",
  "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct RaritiesWithOracle.Rarity[]\",\"name\":\"_rarities\",\"type\":\"tuple[]\"},{\"internalType\":\"contract IOracle\",\"name\":\"_oracle\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct RaritiesWithOracle.Rarity\",\"name\":\"_rarity\",\"type\":\"tuple\"}],\"name\":\"AddRarity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"}],\"name\":\"MetaTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IOracle\",\"name\":\"_oldOracle\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IOracle\",\"name\":\"_newOracle\",\"type\":\"address\"}],\"name\":\"OracleSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"UpdatePrice\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct RaritiesWithOracle.Rarity[]\",\"name\":\"_rarities\",\"type\":\"tuple[]\"}],\"name\":\"addRarities\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"sigR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sigS\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"sigV\",\"type\":\"uint8\"}],\"name\":\"executeMetaTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_rarity\",\"type\":\"string\"}],\"name\":\"getRarityByName\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct RaritiesWithOracle.Rarity\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rarities\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raritiesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"_newOracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_names\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_prices\",\"type\":\"uint256[]\"}],\"name\":\"updatePrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
  "ContractName": "RaritiesWithOracle",
  "CompilerVersion": "v0.7.6+commit.7338295f",
  "OptimizationUsed": "1",
  "Runs": "1",
  "ConstructorArguments": "0000000000000000000000000e659a116e161d8e502f9036babda51334f2667e0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e18b1361d41afc44658216f3dc27e48c2336e3c2000000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000180000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000002c00000000000000000000000000000000000000000000000000000000000000360000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000004a0000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000186a000000000000000000000000000000000000000000000001b1ae4d6e2ef5000000000000000000000000000000000000000000000000000000000000000000006636f6d6d6f6e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000271000000000000000000000000000000000000000000000001b1ae4d6e2ef5000000000000000000000000000000000000000000000000000000000000000000008756e636f6d6d6f6e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000138800000000000000000000000000000000000000000000001b1ae4d6e2ef50000000000000000000000000000000000000000000000000000000000000000000047261726500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000001b1ae4d6e2ef500000000000000000000000000000000000000000000000000000000000000000000465706963000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000001b1ae4d6e2ef50000000000000000000000000000000000000000000000000000000000000000000096c6567656e6461727900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000001b1ae4d6e2ef50000000000000000000000000000000000000000000000000000000000000000000066d797468696300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000001b1ae4d6e2ef5000000000000000000000000000000000000000000000000000000000000000000006756e697175650000000000000000000000000000000000000000000000000000",
  "EVMVersion": "Default",
  "Library": "",
  "LicenseType": "",
  "Proxy": "0",
  "Implementation": "",
  "SwarmSource": ""
}